const int uGradientCount=3;const vec3 uGradientColors[10]=vec3[10](vec3(0.02,0.02,0.035),vec3(0.1,0.1,0.11),vec3(0.02,0.02,0.035),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.));const float uGradientPositions[10]=float[10](0.41,0.58,0.84,0.,0.,0.,0.,0.,0.,0.);vec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}vec4 permute(vec4 x){return mod289((x*34.+1.)*x);}vec4 taylorInvSqrt(vec4 r){return 1.7928429-0.85373473*r;}vec2 fade(vec2 t){return t*t*t*(t*(t*6.-15.)+10.);}float cnoise(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.,0.,1.,1.);vec4 Pf=fract(P.xyxy)-vec4(0.,0.,1.,1.);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1./41.))*2.-1.;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float darknoise(vec2 p){return 0.4*cnoise(p);}float pattern(in vec2 uv,in float time){vec2 q=vec2(9.,0.);q.y=darknoise(uv+vec2(5.2*time,1.3*time));vec2 r=vec2(0.);r.x=darknoise(uv+4.*q+vec2(1.7,9.2));return darknoise(uv+4.*r);}float getBayer8(vec2 pixel){int x=int(mod(pixel.x,8.));int y=int(mod(pixel.y,8.));int index=y*8+x;const float bayer[64]=float[64](0.,32.,8.,40.,2.,34.,10.,42.,48.,16.,56.,24.,50.,18.,58.,26.,12.,44.,4.,36.,14.,46.,6.,38.,60.,28.,52.,20.,62.,30.,54.,22.,3.,35.,11.,43.,1.,33.,9.,41.,51.,19.,59.,27.,49.,17.,57.,25.,15.,47.,7.,39.,13.,45.,5.,37.,63.,31.,55.,23.,61.,29.,53.,21.);return bayer[index];}vec3 sampleGradient(float t){t=clamp(t,0.,1.);for(int i=0;i<9;i++){if(i>=uGradientCount-1)break;float pos1=uGradientPositions[i];float pos2=uGradientPositions[i+1];if(t>=pos1&&t<=pos2){float segmentT=(t-pos1)/(pos2-pos1);return mix(uGradientColors[i],uGradientColors[i+1],segmentT);}}return uGradientColors[uGradientCount-1];}vec3 darklayer(vec2 vUv){vUv/=10.;vec2 uv=(-1.+2.*vUv)/2.;float time=GameTime*80.;float patternValue=pattern(uv,time)*0.5+0.5;patternValue=clamp(patternValue,0.,1.);vec3 color=sampleGradient(patternValue);return clamp(color,0.,1.);}vec4 finishPhantom(vec4 rgb,vec2 dim,vec2 uv){vec3 color=darklayer(uv-rgb.xy*3.-127.)*vec3(2.4,2.4,2.7)*1.24;vec3 color2=clamp((darklayer((uv-rgb.xy*6.)*0.25+GameTime*1000.-63.).r*vec3(2.)-0.16)*2.5,0.,1.);color=color+(1.-(1.-color2)*(1.-color2));float off=color.b-0.02;float adjust=max(0,color.b-0.15)*0.3;return vec4((rgb.r+rgb.g+rgb.b)/3.*color,rgb.a-adjust);}